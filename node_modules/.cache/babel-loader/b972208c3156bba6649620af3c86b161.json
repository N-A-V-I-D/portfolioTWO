{"ast":null,"code":"import { createElement, Fragment, useReducer, useRef, useCallback, useEffect, useMemo, useDebugValue, useContext, createContext, Children, isValidElement, cloneElement } from 'react';\nimport breakLines from 'break-styled-lines';\n\nfunction isPlayedWindup(windup) {\n  return windup.length === 2;\n}\n\nfunction memberIsWindup(member) {\n  // If it's not an array it can't be a windup\n  if (!Array.isArray(member)) {\n    return false;\n  } // If it has less or more than three members it's not a windup\n\n\n  if (member.length !== 3) {\n    return false;\n  } // If its first or second members are not arrays it's not a windup\n\n\n  if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n    return false;\n  } // Past here we just have to hope ElementType isn't a windup.\n\n\n  return true;\n}\n\nfunction windupFromString(str, metadata) {\n  return [[], str.split(\"\"), metadata];\n}\n\nfunction newWindup(arg, metadata) {\n  return [[], arg, metadata];\n}\n\nfunction isUnplayed(windup) {\n  var played = windup[0],\n      remaining = windup[1];\n\n  if (played.length > 0) {\n    return false;\n  }\n\n  return remaining.reduce(function (unplayed, member) {\n    if (memberIsWindup(member)) if (memberIsWindup(windup) && unplayed) {\n      return isUnplayed(member);\n    }\n    return unplayed;\n  }, true);\n}\n\nfunction isFinished(_ref) {\n  var remaining = _ref[1];\n  return remaining.length === 0;\n}\n\nfunction fastForward(windup) {\n  var forwardedWindup = next(windup);\n\n  if (isFinished(forwardedWindup)) {\n    return forwardedWindup;\n  }\n\n  return fastForward(forwardedWindup);\n}\n\nfunction rewind(windup) {\n  if (isUnplayed(windup)) {\n    return windup;\n  }\n\n  var played = windup[0],\n      remaining = windup[1],\n      metadata = windup[2];\n\n  var mapRewind = function mapRewind(member) {\n    if (memberIsWindup(member)) {\n      return rewind(member);\n    }\n\n    return member;\n  };\n\n  return [[], [].concat(played.map(mapRewind), remaining.map(mapRewind)), metadata];\n}\n\nfunction lastPlayedMember(_ref2) {\n  var played = _ref2[0],\n      remaining = _ref2[1];\n  var playedFromRemaining = remaining.reduce(function (playedEl, member) {\n    if (memberIsWindup(member)) {\n      if (!isUnplayed(member)) {\n        return lastPlayedElement(member);\n      }\n    }\n\n    return playedEl;\n  }, undefined);\n\n  if (playedFromRemaining) {\n    return playedFromRemaining;\n  }\n\n  var last = played[played.length - 1];\n  return last;\n}\n\nfunction lastPlayedElement(windup) {\n  var lastPlayed = lastPlayedMember(windup);\n\n  if (memberIsWindup(lastPlayed)) {\n    return lastPlayedElement(lastPlayed);\n  }\n\n  return lastPlayed;\n}\n\nfunction playedElements(_ref3) {\n  var played = _ref3[0],\n      remaining = _ref3[1];\n  var playedTransformed = played.map(function (member) {\n    if (memberIsWindup(member)) {\n      var metadata = member[2];\n      return [playedElements(member), metadata];\n    }\n\n    return member;\n  });\n  var firstRemaning = remaining[0];\n\n  if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n    var metadata = firstRemaning[2];\n    return [].concat(playedTransformed, [[playedElements(firstRemaning), metadata]]);\n  }\n\n  return playedTransformed;\n}\n\nfunction nextElement(_ref4) {\n  var remaining = _ref4[1];\n  var nextVal = remaining[0];\n\n  if (memberIsWindup(nextVal)) {\n    return nextElement(nextVal);\n  }\n\n  return nextVal;\n}\n\nfunction next(windup) {\n  // start\n  // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n  // next\n  // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n  // next\n  // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n  // next\n  // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n  if (isFinished(windup)) {\n    return windup;\n  }\n\n  var played = windup[0],\n      remaining = windup[1],\n      metadata = windup[2];\n  var firstRemaining = remaining[0],\n      restRemaining = remaining.slice(1);\n\n  if (memberIsWindup(firstRemaining)) {\n    var nextFirstRemaining = next(firstRemaining);\n\n    if (isFinished(nextFirstRemaining)) {\n      return [[].concat(played, [nextFirstRemaining]), restRemaining, metadata];\n    }\n\n    return [played, [nextFirstRemaining].concat(restRemaining), metadata];\n  }\n\n  return [[].concat(played, [firstRemaining]), restRemaining, metadata];\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction defaultGetPace(lastChar, nextChar) {\n  switch (lastChar) {\n    case \"—\":\n    case \"…\":\n      return 200;\n\n    case \".\":\n    case \",\":\n      return 150;\n\n    case \"?\":\n    case \"!\":\n      if (nextChar !== \"!\" && nextChar !== \"?\") {\n        return 150;\n      }\n\n      return 20;\n\n    case \"-\":\n    case \" \":\n    case \"\\n\":\n      return 0;\n\n    default:\n      return 20;\n  }\n}\n\nvar Pace = function Pace(_ref) {\n  var children = _ref.children;\n  return createElement(Fragment, null, children);\n};\n\nfunction isPaceElement(element) {\n  return element.type === Pace;\n}\n\nfunction isMsProp(props) {\n  if (\"ms\" in props) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction paceFromWindup(windup, parentPace) {\n  if (isFinished(windup)) {\n    return undefined;\n  }\n\n  var remaining = windup[1],\n      metadata = windup[2];\n  var firstRemaining = remaining[0];\n\n  if (firstRemaining && memberIsWindup(firstRemaining)) {\n    return paceFromWindup(firstRemaining, metadata.pace || parentPace);\n  }\n\n  return metadata.pace || parentPace;\n}\n\nvar OnChar = function OnChar(_ref) {\n  var children = _ref.children;\n  return createElement(Fragment, null, children);\n};\n\nfunction isOnCharElement(element) {\n  return element.type === OnChar;\n} // Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\n\n\nfunction onCharsFromWindup(windup) {\n  var remaining = windup[1],\n      metadata = windup[2];\n  var lastPlayed = lastPlayedMember(windup);\n  var firstRemaining = remaining[0];\n  var onChars = [];\n\n  if (lastPlayed && memberIsWindup(lastPlayed)) {\n    onChars.push.apply(onChars, onCharsFromWindup(lastPlayed));\n  }\n\n  if (firstRemaining && memberIsWindup(firstRemaining) && !isUnplayed(firstRemaining)) {\n    onChars.push.apply(onChars, onCharsFromWindup(firstRemaining));\n  }\n\n  if (metadata.onChar) {\n    onChars.push(metadata.onChar);\n  }\n\n  return onChars;\n}\n\nfunction initWindupState(windup) {\n  return {\n    windup: windup,\n    didFinishOnce: false\n  };\n}\n\nfunction windupReducer(state, action) {\n  switch (action.type) {\n    case \"replace\":\n      return initWindupState(action.windup);\n\n    case \"next\":\n      return _extends({}, state, {\n        windup: next(state.windup)\n      });\n\n    case \"rewind\":\n      return {\n        windup: rewind(state.windup),\n        didFinishOnce: false\n      };\n\n    case \"fast-forward\":\n      return _extends({}, state, {\n        windup: fastForward(state.windup)\n      });\n\n    case \"finish\":\n      return _extends({}, state, {\n        didFinishOnce: true\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction useWindup(windupInit, options) {\n  var _React$useReducer = useReducer(windupReducer, windupInit, initWindupState),\n      _React$useReducer$ = _React$useReducer[0],\n      windup = _React$useReducer$.windup,\n      didFinishOnce = _React$useReducer$.didFinishOnce,\n      dispatch = _React$useReducer[1];\n\n  var timeoutRef = useRef(null);\n  var windupIsFinished = isFinished(windup);\n  var nextCharAtRef = useRef(null);\n  var pauseDelayRemainingRef = useRef(null);\n  var isPausedRef = useRef(false);\n  var skip = useCallback(function () {\n    if (!windupIsFinished) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n  }, [windupIsFinished]);\n  var pause = useCallback(function () {\n    if (isPausedRef.current === true) {\n      return;\n    }\n\n    isPausedRef.current = true;\n\n    if (timeoutRef.current) {\n      var _nextCharAtRef$curren;\n\n      clearTimeout(timeoutRef.current);\n      pauseDelayRemainingRef.current = Math.max(0, ((_nextCharAtRef$curren = nextCharAtRef.current) != null ? _nextCharAtRef$curren : 0) - Date.now());\n    }\n  }, []);\n  var resume = useCallback(function () {\n    if (isPausedRef.current !== true) {\n      return;\n    }\n\n    if (!windupIsFinished) {\n      var _pauseDelayRemainingR;\n\n      setTimeout(function () {\n        isPausedRef.current = false;\n        dispatch({\n          type: \"next\"\n        });\n      }, (_pauseDelayRemainingR = pauseDelayRemainingRef.current) != null ? _pauseDelayRemainingR : 0);\n    }\n  }, [windupIsFinished]);\n  var rewind = useCallback(function () {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    dispatch({\n      type: \"rewind\"\n    });\n  }, []); // If windup arg changes, we should reset\n\n  useEffect(function () {\n    dispatch({\n      type: \"replace\",\n      windup: windupInit\n    });\n  }, [windupInit]); // If skipped is changes to true, we should skip\n  // And if it's changed to false, we should restart\n\n  useEffect(function () {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    if (options.skipped) {\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n\n    if (options.skipped === false) {\n      dispatch({\n        type: \"rewind\"\n      });\n    }\n  }, [options.skipped]); // When the windup changes, onChar should fire\n\n  useEffect(function () {\n    var onChars = onCharsFromWindup(windup);\n    var lastEl = lastPlayedElement(windup);\n\n    if (onChars.length > 0 && lastEl) {\n      onChars.forEach(function (onChar) {\n        onChar(lastEl);\n      });\n    }\n  }, [windup]); // If windup finishes, the onFinished should fire\n\n  useEffect(function () {\n    // Put this in a new context so that the windup finishes visually before firing this\n    if (didFinishOnce === false && windupIsFinished) {\n      var timeout = setTimeout(function () {\n        if (options.onFinished) {\n          options.onFinished();\n        }\n\n        dispatch({\n          type: \"finish\"\n        });\n      }, 0);\n      return function () {\n        clearTimeout(timeout);\n      };\n    }\n  }, [didFinishOnce, windupIsFinished, options]); // the windup effect itself\n\n  useEffect(function () {\n    if (!windupIsFinished) {\n      var getPace = paceFromWindup(windup) || defaultGetPace;\n      var lastEl = lastPlayedElement(windup);\n      var nextEl = nextElement(windup);\n      var pace = lastEl ? getPace(lastEl, nextEl) : 0;\n      nextCharAtRef.current = Date.now() + pace;\n\n      if (isPausedRef.current !== true) {\n        timeoutRef.current = setTimeout(function () {\n          dispatch({\n            type: \"next\"\n          });\n        }, pace);\n      }\n\n      return function () {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n        }\n      };\n    }\n  }, [windup, windupIsFinished]);\n  return {\n    windup: windup,\n    skip: skip,\n    pause: pause,\n    resume: resume,\n    rewind: rewind,\n    isFinished: windupIsFinished\n  };\n}\n\nfunction renderStringWindup(windup) {\n  var played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n  var inner = played.reduce(function (acc, playedEl) {\n    if (typeof playedEl === \"string\") {\n      return acc + playedEl;\n    }\n\n    return acc + renderStringWindup(playedEl);\n  }, \"\");\n  return inner;\n}\n\nvar VOID_TAGS = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"];\n\nfunction renderChildrenWindup(windup) {\n  var metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n  var played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n  var Outer = metadata.element || Fragment;\n\n  if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n    return createElement(Outer, Object.assign({\n      key: metadata.key\n    }, metadata.props));\n  }\n\n  var inner = played.reduce(function (acc, playedEl) {\n    if (typeof playedEl === \"string\") {\n      var accButLast = acc.slice(0, acc.length - 1);\n      var last = acc[acc.length - 1];\n      return last && typeof last === \"string\" ? [].concat(accButLast, [last + playedEl]) : [].concat(acc, [playedEl]);\n    }\n\n    return [].concat(acc, [renderChildrenWindup(playedEl)]);\n  }, []);\n\n  if (typeof metadata.element === \"string\" && VOID_TAGS.includes(metadata.element)) {\n    return createElement(Outer, Object.assign({\n      key: metadata.key\n    }, metadata.props));\n  }\n\n  return createElement(Outer, Object.assign({\n    key: metadata.key\n  }, metadata.props), inner);\n}\n\nfunction useWindupString(text, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var windupInit = useMemo(function () {\n    return windupFromString(text, options); // We can omit options as this is used as an initialisation value and options will not change it\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [text]);\n\n  var _useWindup = useWindup(windupInit, options),\n      windup = _useWindup.windup,\n      skip = _useWindup.skip,\n      pause = _useWindup.pause,\n      resume = _useWindup.resume,\n      rewind = _useWindup.rewind,\n      isFinished = _useWindup.isFinished;\n\n  var rendered = renderStringWindup(windup);\n  useDebugValue(rendered);\n  return [rendered, {\n    skip: skip,\n    pause: pause,\n    resume: resume,\n    rewind: rewind,\n    isFinished: isFinished\n  }];\n}\n\nvar Pause = function Pause() {\n  return null;\n};\n\nfunction isPauseElement(element) {\n  return element.type === Pause;\n}\n\nvar WindupContext = /*#__PURE__*/createContext({\n  skip: function skip() {\n    console.warn(\"Tried to use the useSkip hook outside of a WindupChildren component!!\");\n  },\n  pause: function pause() {\n    console.warn(\"Tried to use the usePause hook outside of a WindupChildren component!!\");\n  },\n  resume: function resume() {\n    console.warn(\"Tried to use the useResume hook outside of a WindupChildren component!!\");\n  },\n  rewind: function rewind() {\n    console.warn(\"Tried to use the useRewind hook outside of a WindupChildren component!\");\n  },\n  isFinished: false\n});\n\nfunction useSkip() {\n  var _React$useContext = useContext(WindupContext),\n      skip = _React$useContext.skip;\n\n  return skip;\n}\n\nfunction useRewind() {\n  var _React$useContext4 = useContext(WindupContext),\n      rewind = _React$useContext4.rewind;\n\n  return rewind;\n}\n\nfunction useIsFinished() {\n  var _React$useContext5 = useContext(WindupContext),\n      isFinished = _React$useContext5.isFinished;\n\n  return isFinished;\n}\n\nfunction reduceWindupArgs(prevArgs, children) {\n  if (typeof children === \"string\") {\n    return [].concat(prevArgs, children.split(\"\"));\n  }\n\n  if (typeof children === \"number\") {\n    return [].concat(prevArgs, children.toString().split(\"\"));\n  }\n\n  if (!isValidElement(children)) {\n    return prevArgs;\n  }\n\n  var _children$props = children.props,\n      childrenChildren = _children$props.children,\n      restProps = _objectWithoutPropertiesLoose(_children$props, [\"children\"]);\n\n  var paceMetaData = isPaceElement(children) ? {\n    pace: function pace(_char) {\n      if (isMsProp(children.props)) {\n        return children.props.ms;\n      }\n\n      return children.props.getPace(_char);\n    }\n  } : {};\n  var onCharMetaData = isOnCharElement(children) ? {\n    onChar: children.props.fn\n  } : {};\n  var keyProp = children.key ? {\n    key: children.key\n  } : {};\n\n  if (isPauseElement(children)) {\n    return [].concat(prevArgs, [windupFromString(\" \", _extends({\n      element: Fragment\n    }, keyProp, {\n      props: {\n        children: undefined\n      },\n      pace: function pace() {\n        return children.props.ms;\n      }\n    }))]);\n  }\n\n  if (childrenChildren === undefined) {\n    return [].concat(prevArgs, [windupFromString(\" \", _extends({\n      element: children.type,\n      props: _extends({}, restProps, {\n        children: undefined\n      })\n    }, keyProp, paceMetaData, onCharMetaData))]);\n  }\n\n  if (typeof childrenChildren === \"string\") {\n    return [].concat(prevArgs, [windupFromString(childrenChildren, _extends({\n      element: children.type,\n      props: restProps\n    }, keyProp, paceMetaData, onCharMetaData))]);\n  }\n\n  if (childrenChildren instanceof Function) {\n    return [].concat(prevArgs, [windupFromString(\" \", _extends({\n      element: children.type,\n      props: _extends({\n        children: childrenChildren\n      }, restProps)\n    }, keyProp, paceMetaData, onCharMetaData))]);\n  }\n\n  var newArgs = Children.toArray(childrenChildren).reduce(reduceWindupArgs, []);\n  var argsWithMetadata = newArgs.map(function (member) {\n    if (memberIsWindup(member)) {\n      var played = member[0],\n          remaining = member[1],\n          metadata = member[2];\n      return [played, remaining, _extends({}, paceMetaData, onCharMetaData, metadata)];\n    }\n\n    return member;\n  });\n  return [].concat(prevArgs, [newWindup(argsWithMetadata, _extends({\n    element: children.type,\n    props: restProps\n  }, keyProp, paceMetaData, onCharMetaData))]);\n}\n\nfunction buildKeyString(children) {\n  if (children === null || children === undefined) {\n    return \"\";\n  }\n\n  var keys = Children.map(children, function (child) {\n    if (typeof child === \"string\") {\n      return child;\n    }\n\n    if (typeof child === \"number\") {\n      return child.toString();\n    }\n\n    if (isValidElement(child)) {\n      return \"#\" + (child.key || \"\") + \"<\" + buildKeyString(child.props.children) + \">\";\n    }\n\n    return \"\";\n  });\n\n  if (!keys) {\n    return \"\";\n  }\n\n  return keys.join(\",\");\n}\n\nfunction useChildrenMemo(factory, children) {\n  // Omitting children in favour of using a key instead\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  var memoChildren = useMemo(factory, [buildKeyString(children)]);\n  return memoChildren;\n}\n\nvar WindupChildren = function WindupChildren(_ref) {\n  var children = _ref.children,\n      onFinished = _ref.onFinished,\n      skipped = _ref.skipped,\n      _ref$isPaused = _ref.isPaused,\n      isPaused = _ref$isPaused === void 0 ? false : _ref$isPaused;\n  var windupInit = useChildrenMemo(function () {\n    return newWindup(Children.toArray(children).reduce(reduceWindupArgs, []), {\n      element: undefined\n    });\n  }, children);\n\n  var _useWindup = useWindup(windupInit, {\n    onFinished: onFinished,\n    skipped: skipped\n  }),\n      windup = _useWindup.windup,\n      skip = _useWindup.skip,\n      pause = _useWindup.pause,\n      resume = _useWindup.resume,\n      rewind = _useWindup.rewind,\n      isFinished = _useWindup.isFinished;\n\n  useEffect(function () {\n    if (isPaused === true) {\n      pause();\n    } else {\n      resume();\n    }\n  }, [isPaused, pause, resume]);\n  return createElement(WindupContext.Provider, {\n    value: {\n      skip: skip,\n      pause: pause,\n      resume: resume,\n      rewind: rewind,\n      isFinished: isFinished\n    }\n  }, renderChildrenWindup(windup));\n};\n\nfunction wrapChildren(children, Wrapper) {\n  if (typeof children === \"string\") {\n    return children.split(\"\").map(function (_char, i) {\n      return _char === \"\\n\" ? _char : createElement(Wrapper, {\n        key: _char + \"-\" + i\n      }, _char);\n    });\n  }\n\n  if (typeof children === \"number\") {\n    return children.toString().split(\"\").map(function (_char2) {\n      return createElement(Wrapper, null, _char2);\n    });\n  }\n\n  if (!isValidElement(children)) {\n    return createElement(Fragment, null);\n  }\n\n  if (children.props.children) {\n    var Outer = children.type;\n\n    if (children.props.children instanceof Function) {\n      return createElement(Outer, Object.assign({\n        key: children.key\n      }, children.props));\n    }\n\n    return createElement(Outer, Object.assign({\n      key: children.key\n    }, children.props), Children.map(children.props.children, function (ch) {\n      return wrapChildren(ch, Wrapper);\n    }));\n  }\n\n  return children;\n}\n\nvar CharWrapper = function CharWrapper(_ref) {\n  var children = _ref.children,\n      element = _ref.element;\n  return createElement(Fragment, null, Children.map(children, function (ch) {\n    return wrapChildren(ch, element);\n  }));\n};\n\nfunction makeGetDescriptorsOfChildren(defaultFontStyle) {\n  return function (descriptors, children) {\n    if (typeof children === \"string\") {\n      return [].concat(descriptors, [{\n        text: children,\n        font: defaultFontStyle\n      }]);\n    }\n\n    if (typeof children === \"number\") {\n      return [].concat(descriptors, [{\n        text: children.toString(),\n        font: defaultFontStyle\n      }]);\n    }\n\n    if (!isValidElement(children)) {\n      return descriptors;\n    }\n\n    if (isStyledTextElement(children) && typeof children.props.children === \"string\") {\n      return [].concat(descriptors, [{\n        text: children.props.children,\n        font: children.props.fontStyle\n      }]);\n    }\n\n    if (isStyledTextElement(children)) {\n      return [].concat(descriptors, Children.toArray(children.props.children).reduce(makeGetDescriptorsOfChildren(children.props.fontStyle), []));\n    }\n\n    return [].concat(descriptors, Children.toArray(children.props.children).reduce(makeGetDescriptorsOfChildren(defaultFontStyle), []));\n  };\n}\n\nfunction reinsertStringsIntoChildren(_ref, children) {\n  var accChildren = _ref[0],\n      accStrings = _ref[1];\n\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    var firstString = accStrings[0],\n        restStrings = accStrings.slice(1);\n    return [[].concat(accChildren, [firstString]), restStrings];\n  }\n\n  if (!isValidElement(children)) {\n    return [accChildren, accStrings];\n  }\n\n  var _React$Children$toArr = Children.toArray(children.props.children).reduce(reinsertStringsIntoChildren, [[], accStrings]),\n      subChildrenAcc = _React$Children$toArr[0],\n      subStringsAcc = _React$Children$toArr[1];\n\n  return [[].concat(accChildren, [cloneElement(children, {\n    children: subChildrenAcc\n  })]), subStringsAcc];\n}\n\nfunction isStyledTextElement(element) {\n  return element.type === StyledText;\n}\n\nfunction StyledText(_ref2) {\n  var children = _ref2.children;\n  return createElement(Fragment, null, children);\n}\n\nvar Linebreaker = function Linebreaker(_ref3) {\n  var children = _ref3.children,\n      fontStyle = _ref3.fontStyle,\n      width = _ref3.width; // CAVEATS:\n  // fontStyle must match the font style of the characters inside\n  // non-character elements must not add width to the line.\n  // must be used OUTSIDE of WindupChildren component\n\n  var childrenArray = Children.toArray(children);\n  var descriptors = childrenArray.reduce(makeGetDescriptorsOfChildren(fontStyle), []);\n  var transformedStrings = breakLines(descriptors, width, fontStyle);\n\n  var _childrenArray$reduce = childrenArray.reduce(reinsertStringsIntoChildren, [[], transformedStrings]),\n      transformedChildren = _childrenArray$reduce[0];\n\n  return createElement(\"div\", {\n    style: {\n      whiteSpace: \"pre\"\n    }\n  }, transformedChildren);\n};\n\nvar Effect = function Effect(_ref) {\n  var fn = _ref.fn;\n  useEffect(function () {\n    fn(); // We can safely omit fn from dependencies as if its value changes\n    // the whole windup will be re-rendered anyway\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return null;\n};\n\nfunction textFromChildren(children) {\n  var text = Children.map(children, function (ch) {\n    if (typeof ch === \"string\") {\n      return ch;\n    }\n\n    if (typeof ch === \"number\") {\n      return ch.toString();\n    }\n\n    if (!isValidElement(ch)) {\n      return \"\";\n    }\n\n    if (ch.props.children) {\n      return textFromChildren(ch.props.children);\n    }\n\n    return \"\";\n  });\n\n  if (!text) {\n    return \"\";\n  }\n\n  return text.join(\"\");\n}\n\nexport { CharWrapper, Effect, Linebreaker, OnChar, Pace, Pause, StyledText, WindupChildren, defaultGetPace, textFromChildren, useIsFinished, useRewind, useSkip, useWindupString };","map":{"version":3,"mappings":"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","names":["isPlayedWindup","windup","length","memberIsWindup","member","Array","isArray","windupFromString","str","metadata","split","newWindup","arg","isUnplayed","played","remaining","reduce","unplayed","isFinished","fastForward","forwardedWindup","next","rewind","mapRewind","map","lastPlayedMember","playedFromRemaining","playedEl","lastPlayedElement","undefined","last","lastPlayed","playedElements","playedTransformed","firstRemaning","nextElement","nextVal","firstRemaining","restRemaining","nextFirstRemaining","defaultGetPace","lastChar","nextChar","Pace","children","React","isPaceElement","element","type","isMsProp","props","paceFromWindup","parentPace","pace","OnChar","isOnCharElement","onCharsFromWindup","onChars","push","onChar","initWindupState","didFinishOnce","windupReducer","state","action","useWindup","windupInit","options","dispatch","timeoutRef","windupIsFinished","nextCharAtRef","pauseDelayRemainingRef","isPausedRef","skip","current","clearTimeout","pause","Math","max","Date","now","resume","setTimeout","skipped","lastEl","forEach","timeout","onFinished","getPace","nextEl","renderStringWindup","inner","acc","VOID_TAGS","renderChildrenWindup","Outer","Object","keys","includes","key","accButLast","slice","useWindupString","text","rendered","Pause","isPauseElement","WindupContext","console","warn","useSkip","useRewind","useIsFinished","reduceWindupArgs","prevArgs","toString","childrenChildren","restProps","paceMetaData","char","ms","onCharMetaData","fn","keyProp","Function","newArgs","toArray","argsWithMetadata","buildKeyString","child","join","useChildrenMemo","factory","memoChildren","WindupChildren","isPaused","_ref$isPaused","Provider","value","wrapChildren","Wrapper","i","ch","CharWrapper","makeGetDescriptorsOfChildren","defaultFontStyle","descriptors","font","isStyledTextElement","fontStyle","reinsertStringsIntoChildren","accChildren","accStrings","firstString","restStrings","subChildrenAcc","subStringsAcc","StyledText","Linebreaker","width","childrenArray","transformedStrings","breakLines","transformedChildren","style","whiteSpace","Effect","textFromChildren"],"sources":["E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\Windup.ts","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\Pace.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\OnChar.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\useWindup.ts","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\renderWindup.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\useWindupString.ts","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\Pause.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\WindupChildren.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\CharWrapper.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\Linebreaker.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\Effect.tsx","E:\\portfolio\\Portfolio-Website\\node_modules\\windups\\src\\react\\textFromChildren.ts"],"sourcesContent":["export type WindupMember<ElementType, MetadataType> =\n  | ElementType\n  | Windup<ElementType, MetadataType>;\nexport type Windup<ElementType, MetadataType> = [\n  Array<WindupMember<ElementType, MetadataType>>,\n  Array<WindupMember<ElementType, MetadataType>>,\n  MetadataType\n];\n\nexport function isPlayedWindup<ElementType, MetadataType>(\n  windup:\n    | PlayedWindup<ElementType, MetadataType>\n    | Windup<ElementType, MetadataType>\n): windup is PlayedWindup<ElementType, MetadataType> {\n  return windup.length === 2;\n}\n\nexport function memberIsWindup<ElementType, MetadataType>(\n  member: WindupMember<ElementType, MetadataType>\n): member is Windup<ElementType, MetadataType> {\n  // If it's not an array it can't be a windup\n  if (!Array.isArray(member)) {\n    return false;\n  }\n\n  // If it has less or more than three members it's not a windup\n  if (member.length !== 3) {\n    return false;\n  }\n\n  // If its first or second members are not arrays it's not a windup\n  if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n    return false;\n  }\n\n  // Past here we just have to hope ElementType isn't a windup.\n  return true;\n}\n\nexport function windupFromString<MetadataType>(\n  str: string,\n  metadata: MetadataType\n): Windup<string, MetadataType> {\n  return [[], str.split(\"\"), metadata];\n}\n\nexport function newWindup<ElementType, MetadataType>(\n  arg: Array<WindupMember<ElementType, MetadataType>>,\n  metadata: MetadataType\n): Windup<ElementType, MetadataType> {\n  return [[], arg, metadata];\n}\n\nexport function isUnplayed<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): boolean {\n  const [played, remaining] = windup;\n\n  if (played.length > 0) {\n    return false;\n  }\n\n  return remaining.reduce((unplayed: boolean, member) => {\n    if (memberIsWindup(member))\n      if (memberIsWindup(windup) && unplayed) {\n        return isUnplayed<ElementType, MetadataType>(member);\n      }\n    return unplayed;\n  }, true);\n}\n\nexport function isFinished<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): boolean {\n  return remaining.length === 0;\n}\n\nexport function fastForward<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  const forwardedWindup = next(windup);\n  if (isFinished(forwardedWindup)) {\n    return forwardedWindup;\n  }\n  return fastForward(forwardedWindup);\n}\n\nexport function rewind<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  if (isUnplayed(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n\n  type MemberType = WindupMember<ElementType, MetadataType>;\n\n  const mapRewind = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return rewind(member);\n    }\n    return member;\n  };\n\n  return [\n    [],\n    [...played.map(mapRewind), ...remaining.map(mapRewind)],\n    metadata\n  ];\n}\n\nexport function windupAsString<MetadataType>(\n  windup: Windup<string, MetadataType>\n): string {\n  const [played, remaining] = windup;\n\n  type MemberType = WindupMember<string, MetadataType>;\n  const stringify = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return windupAsString(member);\n    }\n    return member;\n  };\n  return [\n    played.map(stringify).join(\"\"),\n    remaining.map(stringify).join(\"\")\n  ].join(\"\");\n}\n\nexport function lastPlayedMember<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>):\n  | WindupMember<ElementType, MetadataType>\n  | undefined {\n  const playedFromRemaining = remaining.reduce(\n    (playedEl: WindupMember<ElementType, MetadataType> | undefined, member) => {\n      if (memberIsWindup(member)) {\n        if (!isUnplayed(member)) {\n          return lastPlayedElement(member);\n        }\n      }\n      return playedEl;\n    },\n    undefined\n  );\n\n  if (playedFromRemaining) {\n    return playedFromRemaining;\n  }\n\n  const last = played[played.length - 1];\n  return last;\n}\n\nexport function lastPlayedElement<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): ElementType | undefined {\n  const lastPlayed = lastPlayedMember(windup);\n\n  if (memberIsWindup(lastPlayed)) {\n    return lastPlayedElement(lastPlayed);\n  }\n\n  return lastPlayed;\n}\n\nexport type PlayedWindup<ElementType, MetadataType> = [\n  Array<ElementType>,\n  MetadataType\n];\n\nexport function playedElements<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>): Array<\n  ElementType | PlayedWindup<ElementType, MetadataType>\n> {\n  const playedTransformed = played.map(member => {\n    if (memberIsWindup(member)) {\n      const [, , metadata] = member;\n      return [playedElements(member), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >;\n    }\n    return member;\n  });\n\n  const [firstRemaning] = remaining;\n  if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n    const [, , metadata] = firstRemaning;\n\n    return [\n      ...playedTransformed,\n      [playedElements(firstRemaning), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >\n    ];\n  }\n\n  return playedTransformed;\n}\n\nexport function nextElement<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): ElementType | undefined {\n  const [nextVal] = remaining;\n\n  if (memberIsWindup(nextVal)) {\n    return nextElement(nextVal);\n  }\n\n  return nextVal;\n}\n\nexport function next<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  // start\n  // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n\n  // next\n  // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n\n  // next\n  // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n\n  // next\n  // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n\n  if (isFinished(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n  const [firstRemaining, ...restRemaining] = remaining;\n\n  if (memberIsWindup(firstRemaining)) {\n    const nextFirstRemaining = next(firstRemaining);\n\n    if (isFinished(nextFirstRemaining)) {\n      return [[...played, nextFirstRemaining], restRemaining, metadata];\n    }\n\n    return [played, [nextFirstRemaining, ...restRemaining], metadata];\n  }\n\n  return [[...played, firstRemaining], restRemaining, metadata];\n}\n","import * as React from \"react\";\nimport { isFinished, memberIsWindup, Windup } from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype MsProp = {\n  ms: number;\n};\n\ntype GetPaceProp = {\n  getPace: (char: string) => number;\n};\n\ntype PaceProps = MsProp | GetPaceProp;\n\nexport function defaultGetPace(\n  lastChar: string,\n  nextChar: string | undefined\n): number {\n  switch (lastChar) {\n    case \"—\":\n    case \"…\":\n      return 200;\n    case \".\":\n    case \",\":\n      return 150;\n    case \"?\":\n    case \"!\":\n      if (nextChar !== \"!\" && nextChar !== \"?\") {\n        return 150;\n      }\n      return 20;\n    case \"-\":\n    case \" \":\n    case \"\\n\":\n      return 0;\n    default:\n      return 20;\n  }\n}\n\nconst Pace: React.FC<React.PropsWithChildren<PaceProps>> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isPaceElement(\n  element: React.ReactElement\n): element is React.ReactElement<PaceProps> {\n  return element.type === Pace;\n}\n\nexport function isMsProp(props: PaceProps): props is MsProp {\n  if (\"ms\" in props) {\n    return true;\n  }\n  return false;\n}\n\nexport function paceFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(\n  windup: W,\n  parentPace?: (char: string, nextChar: string | undefined) => number\n): ((char: string, nextChar: string | undefined) => number) | undefined {\n  if (isFinished(windup)) {\n    return undefined;\n  }\n\n  const [, remaining, metadata] = windup;\n\n  const [firstRemaining] = remaining;\n\n  if (firstRemaining && memberIsWindup(firstRemaining)) {\n    return paceFromWindup(firstRemaining, metadata.pace || parentPace);\n  }\n\n  return metadata.pace || parentPace;\n}\n\nexport default Pace;\n","import * as React from \"react\";\nimport {\n  memberIsWindup,\n  Windup,\n  lastPlayedMember,\n  isUnplayed\n} from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype OnCharProps = {\n  children: React.ReactNode;\n  fn: (char: string) => void;\n};\n\nconst OnChar: React.FC<OnCharProps> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isOnCharElement(\n  element: React.ReactElement\n): element is React.ReactElement<OnCharProps> {\n  return element.type === OnChar;\n}\n\n// Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\nexport function onCharsFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(windup: W): ((char: string) => void)[] {\n  const [, remaining, metadata] = windup;\n  const lastPlayed = lastPlayedMember(windup);\n  const [firstRemaining] = remaining;\n\n  let onChars = [];\n\n  if (lastPlayed && memberIsWindup(lastPlayed)) {\n    onChars.push(...onCharsFromWindup(lastPlayed));\n  }\n\n  if (\n    firstRemaining &&\n    memberIsWindup(firstRemaining) &&\n    !isUnplayed(firstRemaining)\n  ) {\n    onChars.push(...onCharsFromWindup(firstRemaining));\n  }\n\n  if (metadata.onChar) {\n    onChars.push(metadata.onChar);\n  }\n\n  return onChars;\n}\n\nexport default OnChar;\n","import * as React from \"react\";\nimport { defaultGetPace, paceFromWindup } from \"./Pace\";\nimport {\n  isFinished,\n  lastPlayedElement,\n  next,\n  fastForward,\n  rewind,\n  Windup,\n  nextElement\n} from \"../Windup\";\nimport { onCharsFromWindup } from \"./OnChar\";\n\ntype WindupReducerState<M> = {\n  windup: Windup<string, M>;\n  didFinishOnce: boolean;\n};\n\ntype WindupReducerAction<M> =\n  | {\n      type: \"replace\";\n      windup: Windup<string, M>;\n    }\n  | {\n      type: \"next\";\n    }\n  | {\n      type: \"rewind\";\n    }\n  | {\n      type: \"fast-forward\";\n    }\n  | {\n      type: \"finish\";\n    };\n\nfunction initWindupState<M>(windup: Windup<string, M>): WindupReducerState<M> {\n  return { windup, didFinishOnce: false };\n}\n\ntype ReducerType<M> = (\n  prevState: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n) => WindupReducerState<M>;\n\nfunction windupReducer<M>(\n  state: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n): WindupReducerState<M> {\n  switch (action.type) {\n    case \"replace\":\n      return initWindupState(action.windup);\n    case \"next\":\n      return { ...state, windup: next(state.windup) };\n    case \"rewind\":\n      return { windup: rewind(state.windup), didFinishOnce: false };\n    case \"fast-forward\":\n      return { ...state, windup: fastForward(state.windup) };\n    case \"finish\":\n      return { ...state, didFinishOnce: true };\n    default:\n      return state;\n  }\n}\n\nexport interface HookMetadata {\n  onChar?: (char: string) => void;\n  pace?: (char: string, nextChar: string | undefined) => number;\n}\n\nexport default function useWindup<M extends HookMetadata>(\n  windupInit: Windup<string, M>,\n  options: {\n    onFinished?: () => void;\n    skipped?: boolean;\n  }\n): {\n  windup: Windup<string, M>;\n  skip: () => void;\n  pause: () => void;\n  resume: () => void;\n  rewind: () => void;\n  isFinished: boolean;\n} {\n  const [{ windup, didFinishOnce }, dispatch] = React.useReducer<\n    ReducerType<M>,\n    Windup<string, M>\n  >(windupReducer, windupInit, initWindupState);\n\n  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);\n  const windupIsFinished = isFinished(windup);\n\n  const nextCharAtRef = React.useRef<number | null>(null);\n  const pauseDelayRemainingRef = React.useRef<number | null>(null);\n  const isPausedRef = React.useRef<boolean>(false);\n\n  const skip = React.useCallback(() => {\n    if (!windupIsFinished) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n  }, [windupIsFinished]);\n\n  const pause = React.useCallback(() => {\n    if (isPausedRef.current === true) {\n      return;\n    }\n\n    isPausedRef.current = true;\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      pauseDelayRemainingRef.current = Math.max(\n        0,\n        (nextCharAtRef.current ?? 0) - Date.now()\n      );\n    }\n  }, []);\n\n  const resume = React.useCallback(() => {\n    if (isPausedRef.current !== true) {\n      return;\n    }\n\n    if (!windupIsFinished) {\n      setTimeout(() => {\n        isPausedRef.current = false;\n        dispatch({ type: \"next\" });\n      }, pauseDelayRemainingRef.current ?? 0);\n    }\n  }, [windupIsFinished]);\n\n  const rewind = React.useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    dispatch({ type: \"rewind\" });\n  }, []);\n\n  // If windup arg changes, we should reset\n  React.useEffect(() => {\n    dispatch({ type: \"replace\", windup: windupInit });\n  }, [windupInit]);\n\n  // If skipped is changes to true, we should skip\n  // And if it's changed to false, we should restart\n  React.useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    if (options.skipped) {\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n    if (options.skipped === false) {\n      dispatch({ type: \"rewind\" });\n    }\n  }, [options.skipped]);\n\n  // When the windup changes, onChar should fire\n  React.useEffect(() => {\n    const onChars = onCharsFromWindup(windup);\n    const lastEl = lastPlayedElement(windup);\n    if (onChars.length > 0 && lastEl) {\n      onChars.forEach(onChar => {\n        onChar(lastEl);\n      });\n    }\n  }, [windup]);\n\n  // If windup finishes, the onFinished should fire\n  React.useEffect(() => {\n    // Put this in a new context so that the windup finishes visually before firing this\n    if (didFinishOnce === false && windupIsFinished) {\n      const timeout = setTimeout(() => {\n        if (options.onFinished) {\n          options.onFinished();\n        }\n        dispatch({ type: \"finish\" });\n      }, 0);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [didFinishOnce, windupIsFinished, options]);\n\n  // the windup effect itself\n  React.useEffect(() => {\n    if (!windupIsFinished) {\n      const getPace = paceFromWindup(windup) || defaultGetPace;\n      const lastEl = lastPlayedElement(windup);\n      const nextEl = nextElement(windup);\n\n      const pace = lastEl ? getPace(lastEl, nextEl) : 0;\n\n      nextCharAtRef.current = Date.now() + pace;\n\n      if (isPausedRef.current !== true) {\n        timeoutRef.current = setTimeout(() => {\n          dispatch({ type: \"next\" });\n        }, pace);\n      }\n\n      return () => {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n        }\n      };\n    }\n  }, [windup, windupIsFinished]);\n\n  return {\n    windup,\n    skip,\n    pause,\n    resume,\n    rewind,\n    isFinished: windupIsFinished\n  };\n}\n","import * as React from \"react\";\nimport { ChildrenMetadata, ChildrenWindup } from \"./WindupChildren\";\nimport { PlayedWindup, playedElements, isPlayedWindup } from \"../Windup\";\nimport { StringMetadata, StringWindup } from \"./useWindupString\";\n\nexport type PlayedChildrenWindup = PlayedWindup<string, ChildrenMetadata>;\nexport type PlayedStringWindup = PlayedWindup<string, StringMetadata>;\n\nexport function renderStringWindup(\n  windup: StringWindup | PlayedStringWindup\n): string {\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const inner = played.reduce((acc: string, playedEl) => {\n    if (typeof playedEl === \"string\") {\n      return acc + playedEl;\n    }\n\n    return acc + renderStringWindup(playedEl);\n  }, \"\");\n\n  return inner;\n}\n\nconst VOID_TAGS = [\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"command\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n];\n\nexport function renderChildrenWindup(\n  windup: ChildrenWindup | PlayedChildrenWindup\n): React.ReactNode {\n  const metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const Outer = metadata.element || React.Fragment;\n\n  if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  const inner = played.reduce((acc: React.ReactNode[], playedEl) => {\n    if (typeof playedEl === \"string\") {\n      const accButLast = acc.slice(0, acc.length - 1);\n      const last = acc[acc.length - 1];\n\n      return last && typeof last === \"string\"\n        ? [...accButLast, last + playedEl]\n        : [...acc, playedEl];\n    }\n\n    return [...acc, renderChildrenWindup(playedEl)];\n  }, []);\n\n  if (\n    typeof metadata.element === \"string\" &&\n    VOID_TAGS.includes(metadata.element)\n  ) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  return (\n    <Outer key={metadata.key} {...metadata.props}>\n      {inner}\n    </Outer>\n  );\n}\n","import * as React from \"react\";\nimport { windupFromString, Windup } from \"../Windup\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderStringWindup } from \"./renderWindup\";\n\nexport type WindupOptions = {\n  onChar?: (char: string) => void;\n  onFinished?: () => void;\n  pace?: (char: string) => number;\n  skipped?: boolean;\n};\n\nexport type StringMetadata = HookMetadata;\n\nexport type StringWindup = Windup<string, StringMetadata>;\n\nexport default function useWindupString(\n  text: string,\n  options: WindupOptions = {}\n): [\n  string,\n  {\n    skip: () => void;\n    pause: () => void;\n    resume: () => void;\n    rewind: () => void;\n    isFinished: boolean;\n  }\n] {\n  const windupInit = React.useMemo(() => {\n    return windupFromString<StringMetadata>(text, options);\n    // We can omit options as this is used as an initialisation value and options will not change it\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [text]);\n\n  const { windup, skip, pause, resume, rewind, isFinished } = useWindup(\n    windupInit,\n    options\n  );\n\n  const rendered = renderStringWindup(windup);\n  React.useDebugValue(rendered);\n\n  return [rendered, { skip, pause, resume, rewind, isFinished }];\n}\n","import * as React from \"react\";\n\ntype PauseProps = {\n  ms: number;\n};\n\nconst Pause: React.FC<PauseProps> = () => {\n  return null;\n};\n\nexport function isPauseElement(\n  element: React.ReactElement\n): element is React.ReactElement<PauseProps> {\n  return element.type === Pause;\n}\n\nexport default Pause;\n","import * as React from \"react\";\nimport {\n  newWindup,\n  Windup,\n  WindupMember,\n  windupFromString,\n  memberIsWindup\n} from \"../Windup\";\nimport { isPaceElement, isMsProp } from \"./Pace\";\nimport { isOnCharElement } from \"./OnChar\";\nimport { isPauseElement } from \"./Pause\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderChildrenWindup } from \"./renderWindup\";\n\nconst WindupContext = React.createContext({\n  skip: () => {\n    console.warn(\n      \"Tried to use the useSkip hook outside of a WindupChildren component!!\"\n    );\n  },\n  pause: () => {\n    console.warn(\n      \"Tried to use the usePause hook outside of a WindupChildren component!!\"\n    );\n  },\n  resume: () => {\n    console.warn(\n      \"Tried to use the useResume hook outside of a WindupChildren component!!\"\n    );\n  },\n  rewind: () => {\n    console.warn(\n      \"Tried to use the useRewind hook outside of a WindupChildren component!\"\n    );\n  },\n  isFinished: false\n});\n\nexport function useSkip() {\n  const { skip } = React.useContext(WindupContext);\n  return skip;\n}\n\nexport function usePause() {\n  const { pause } = React.useContext(WindupContext);\n  return pause;\n}\n\nexport function useResume() {\n  const { resume } = React.useContext(WindupContext);\n  return resume;\n}\n\nexport function useRewind() {\n  const { rewind } = React.useContext(WindupContext);\n  return rewind;\n}\n\nexport function useIsFinished() {\n  const { isFinished } = React.useContext(WindupContext);\n  return isFinished;\n}\n\nexport interface ChildrenMetadata extends HookMetadata {\n  element: React.ElementType | string | undefined;\n  props?: any;\n  ref?: any;\n  key?: string | number | null;\n}\n\nexport type ChildrenWindup = Windup<string, ChildrenMetadata>;\ntype ChildrenWindupMember = WindupMember<string, ChildrenMetadata>;\n\nfunction reduceWindupArgs(\n  prevArgs: ChildrenWindupMember[],\n  children: React.ReactNode\n) {\n  if (typeof children === \"string\") {\n    return [...prevArgs, ...children.split(\"\")];\n  }\n\n  if (typeof children === \"number\") {\n    return [...prevArgs, ...children.toString().split(\"\")];\n  }\n\n  if (!React.isValidElement(children)) {\n    return prevArgs;\n  }\n\n  const { children: childrenChildren, ...restProps } = children.props;\n\n  const paceMetaData = isPaceElement(children)\n    ? {\n        pace: (char: string) => {\n          if (isMsProp(children.props)) {\n            return children.props.ms;\n          }\n          return children.props.getPace(char);\n        }\n      }\n    : {};\n\n  const onCharMetaData = isOnCharElement(children)\n    ? {\n        onChar: children.props.fn\n      }\n    : {};\n\n  const keyProp = children.key ? { key: children.key } : {};\n\n  if (isPauseElement(children)) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: React.Fragment,\n        ...keyProp,\n        props: { children: undefined },\n        pace: () => children.props.ms\n      })\n    ];\n  }\n\n  if (childrenChildren === undefined) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { ...restProps, children: undefined },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (typeof childrenChildren === \"string\") {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(childrenChildren, {\n        element: children.type,\n        props: restProps,\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (childrenChildren instanceof Function) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { children: childrenChildren, ...restProps },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  const newArgs: ChildrenWindupMember[] = React.Children.toArray(\n    childrenChildren\n  ).reduce(reduceWindupArgs, []);\n\n  const argsWithMetadata = newArgs.map(member => {\n    if (memberIsWindup(member)) {\n      const [played, remaining, metadata] = member;\n      return [\n        played,\n        remaining,\n        {\n          ...paceMetaData,\n          ...onCharMetaData,\n          ...metadata\n        }\n      ] as ChildrenWindupMember;\n    }\n    return member;\n  });\n\n  return [\n    ...prevArgs,\n    newWindup<string, ChildrenMetadata>(argsWithMetadata, {\n      element: children.type,\n      props: restProps,\n      ...keyProp,\n      ...paceMetaData,\n      ...onCharMetaData\n    })\n  ];\n}\n\ntype WindupChildrenProps = {\n  children: React.ReactNode;\n  onFinished?: () => void;\n  skipped?: boolean;\n  isPaused?: boolean;\n};\n\nfunction buildKeyString(children: React.ReactNode): string {\n  if (children === null || children === undefined) {\n    return \"\";\n  }\n\n  const keys = React.Children.map(children, child => {\n    if (typeof child === \"string\") {\n      return child;\n    }\n\n    if (typeof child === \"number\") {\n      return child.toString();\n    }\n\n    if (React.isValidElement(child)) {\n      return `#${child.key || \"\"}<${buildKeyString(child.props.children)}>`;\n    }\n\n    return \"\";\n  });\n\n  if (!keys) {\n    return \"\";\n  }\n\n  return keys.join(\",\");\n}\n\nfunction useChildrenMemo<T>(factory: () => T, children: React.ReactNode) {\n  // Omitting children in favour of using a key instead\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoChildren = React.useMemo(factory, [buildKeyString(children)]);\n\n  return memoChildren;\n}\n\nconst WindupChildren: React.FC<WindupChildrenProps> = ({\n  children,\n  onFinished,\n  skipped,\n  isPaused = false\n}) => {\n  const windupInit = useChildrenMemo(() => {\n    return newWindup<string, ChildrenMetadata>(\n      React.Children.toArray(children).reduce(reduceWindupArgs, []),\n      { element: undefined }\n    );\n  }, children);\n\n  const { windup, skip, pause, resume, rewind, isFinished } = useWindup(\n    windupInit,\n    {\n      onFinished,\n      skipped\n    }\n  );\n\n  React.useEffect(() => {\n    if (isPaused === true) {\n      pause();\n    } else {\n      resume();\n    }\n  }, [isPaused, pause, resume]);\n\n  return (\n    <WindupContext.Provider\n      value={{\n        skip,\n        pause,\n        resume,\n        rewind,\n        isFinished\n      }}\n    >\n      {renderChildrenWindup(windup)}\n    </WindupContext.Provider>\n  );\n};\n\nexport default WindupChildren;\n","import * as React from \"react\";\n\ntype CharWrapperProps = {\n  children: React.ReactNode;\n  element: React.ElementType;\n};\n\nfunction wrapChildren(children: React.ReactNode, Wrapper: React.ElementType) {\n  if (typeof children === \"string\") {\n    return children\n      .split(\"\")\n      .map((char, i) =>\n        char === \"\\n\" ? char : <Wrapper key={`${char}-${i}`}>{char}</Wrapper>\n      );\n  }\n\n  if (typeof children === \"number\") {\n    return children\n      .toString()\n      .split(\"\")\n      .map(char => <Wrapper>{char}</Wrapper>);\n  }\n\n  if (!React.isValidElement(children)) {\n    return <React.Fragment />;\n  }\n\n  if (children.props.children) {\n    const Outer = children.type;\n\n    if (children.props.children instanceof Function) {\n      return <Outer key={children.key} {...children.props} />;\n    }\n\n    return (\n      <Outer key={children.key} {...children.props}>\n        {React.Children.map(children.props.children, ch => {\n          return wrapChildren(ch, Wrapper);\n        })}\n      </Outer>\n    );\n  }\n\n  return children;\n}\n\nconst CharWrapper: React.FC<CharWrapperProps> = ({ children, element }) => {\n  return (\n    <>\n      {React.Children.map(children, ch => {\n        return wrapChildren(ch, element);\n      })}\n    </>\n  );\n};\n\nexport default CharWrapper;\n","import * as React from \"react\";\nimport breakLines from \"break-styled-lines\";\n\nfunction makeGetDescriptorsOfChildren(defaultFontStyle: string) {\n  return (\n    descriptors: { text: string; font: string }[],\n    children: React.ReactNode\n  ): { text: string; font: string }[] => {\n    if (typeof children === \"string\") {\n      return [...descriptors, { text: children, font: defaultFontStyle }];\n    }\n\n    if (typeof children === \"number\") {\n      return [\n        ...descriptors,\n        { text: children.toString(), font: defaultFontStyle }\n      ];\n    }\n\n    if (!React.isValidElement(children)) {\n      return descriptors;\n    }\n\n    if (\n      isStyledTextElement(children) &&\n      typeof children.props.children === \"string\"\n    ) {\n      return [\n        ...descriptors,\n        { text: children.props.children, font: children.props.fontStyle }\n      ];\n    }\n\n    if (isStyledTextElement(children)) {\n      return [\n        ...descriptors,\n        ...React.Children.toArray(children.props.children).reduce(\n          makeGetDescriptorsOfChildren(children.props.fontStyle),\n          []\n        )\n      ];\n    }\n\n    return [\n      ...descriptors,\n      ...React.Children.toArray(children.props.children).reduce(\n        makeGetDescriptorsOfChildren(defaultFontStyle),\n        []\n      )\n    ];\n  };\n}\n\nfunction reinsertStringsIntoChildren(\n  [accChildren, accStrings]: [React.ReactNode[], string[]],\n  children: React.ReactNode\n): [React.ReactNode[], string[]] {\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    const [firstString, ...restStrings] = accStrings;\n    return [[...accChildren, firstString], restStrings];\n  }\n\n  if (!React.isValidElement(children)) {\n    return [accChildren, accStrings];\n  }\n\n  const [subChildrenAcc, subStringsAcc] = React.Children.toArray(\n    children.props.children\n  ).reduce(reinsertStringsIntoChildren, [[], accStrings]);\n\n  return [\n    [\n      ...accChildren,\n      React.cloneElement(children, {\n        children: subChildrenAcc\n      })\n    ],\n    subStringsAcc\n  ];\n}\n\ntype StyledTextProps = { children: React.ReactNode; fontStyle: string };\n\nfunction isStyledTextElement(\n  element: React.ReactElement\n): element is React.ReactElement<StyledTextProps> {\n  return element.type === StyledText;\n}\n\nexport function StyledText({ children }: StyledTextProps) {\n  return <>{children}</>;\n}\n\ntype LinebreakerProps = {\n  children: React.ReactNode;\n  fontStyle: string;\n  width: number;\n};\n\nconst Linebreaker: React.FC<LinebreakerProps> = ({\n  children,\n  fontStyle,\n  width\n}) => {\n  // CAVEATS:\n  // fontStyle must match the font style of the characters inside\n  // non-character elements must not add width to the line.\n  // must be used OUTSIDE of WindupChildren component\n\n  const childrenArray = React.Children.toArray(children);\n  const descriptors = childrenArray.reduce(\n    makeGetDescriptorsOfChildren(fontStyle),\n    []\n  );\n\n  const transformedStrings = breakLines(descriptors, width, fontStyle);\n\n  const [\n    transformedChildren\n  ] = childrenArray.reduce(reinsertStringsIntoChildren, [\n    [],\n    transformedStrings\n  ]);\n\n  return <div style={{ whiteSpace: \"pre\" }}>{transformedChildren}</div>;\n};\n\nexport default Linebreaker;\n","import * as React from \"react\";\n\ntype EffectProps = {\n  fn: () => void;\n};\n\nconst Effect: React.FC<EffectProps> = ({ fn }) => {\n  React.useEffect(() => {\n    fn();\n    // We can safely omit fn from dependencies as if its value changes\n    // the whole windup will be re-rendered anyway\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return null;\n};\n\nexport default Effect;\n","import * as React from \"react\";\n\nexport default function textFromChildren(children: React.ReactNode): string {\n  const text = React.Children.map(children, ch => {\n    if (typeof ch === \"string\") {\n      return ch;\n    }\n\n    if (typeof ch === \"number\") {\n      return ch.toString();\n    }\n\n    if (!React.isValidElement(ch)) {\n      return \"\";\n    }\n\n    if (ch.props.children) {\n      return textFromChildren(ch.props.children);\n    }\n\n    return \"\";\n  });\n\n  if (!text) {\n    return \"\";\n  }\n\n  return text.join(\"\");\n}\n"]},"metadata":{},"sourceType":"module"}