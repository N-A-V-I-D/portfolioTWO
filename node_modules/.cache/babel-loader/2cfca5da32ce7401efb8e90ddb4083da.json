{"ast":null,"code":"// src/break-lines.ts\nfunction checkFontForBlinkMacSystemFont(font) {\n  if (font.includes(\"BlinkMacSystemFont\")) {\n    console.warn(\"break-styled-lines: Using BlinkMacSystemFont can cause Chrome to crash in certain environments!\");\n  }\n}\n\nfunction isStringArray(text) {\n  return Array.isArray(text) && (text.length > 0 ? typeof text[0] === \"string\" : true);\n}\n\nfunction isTextDescriptorArray(text) {\n  return Array.isArray(text) && (text.length > 0 ? !isStringArray(text) : true);\n}\n\nfunction withNewLines(descriptor, width, startingX, ctx) {\n  const elements = descriptor.text.split(\"\").reduce((elements2, char) => {\n    const runningElement = elements2[elements2.length - 1] || \"\";\n    const lastChar = runningElement.slice(-1);\n\n    if (char === \" \" && lastChar !== \" \") {\n      return [...elements2, char];\n    }\n\n    if (char !== \" \" && lastChar === \" \") {\n      return [...elements2, char];\n    }\n\n    return [...elements2.slice(0, -1), `${runningElement}${char}`];\n  }, []);\n  const {\n    lastLineWidth,\n    lines\n  } = elements.reduce((result, element) => {\n    ctx.font = descriptor.font;\n    const {\n      width: elementWidth\n    } = ctx.measureText(element);\n    const completeTextWidth = result.lastLineWidth + elementWidth;\n    const itFits = completeTextWidth <= width;\n\n    if (itFits) {\n      const appendedLine = [...result.lines.slice(-1), element].join(\"\");\n      return {\n        lastLineWidth: completeTextWidth,\n        lines: [...result.lines.slice(0, -1), appendedLine]\n      };\n    }\n\n    if (elementWidth > width && result.lastLineWidth === 0) {\n      return {\n        lastLineWidth: elementWidth,\n        lines: [...result.lines.slice(0, -1), element]\n      };\n    }\n\n    const previousLine = result.lines.slice(-1).join(\"\");\n    const precedingLines = [...result.lines.slice(0, -1), previousLine.trimEnd()];\n\n    if (element.trim().length === 0) {\n      return {\n        lastLineWidth: 0,\n        lines: [...precedingLines, \"\"]\n      };\n    }\n\n    return {\n      lastLineWidth: elementWidth,\n      lines: [...precedingLines, element]\n    };\n  }, {\n    lastLineWidth: startingX,\n    lines: []\n  });\n  return {\n    lastLineWidth,\n    text: lines.join(\"\\n\")\n  };\n}\n\nfunction breakLines(descriptors, width) {\n  const supportsOffscreenCanvas = (\"OffscreenCanvas\" in window);\n  const canvasEl = document.createElement(\"canvas\");\n  const canvas = supportsOffscreenCanvas ? canvasEl.transferControlToOffscreen() : canvasEl;\n  canvas.width = width;\n  const ctx = canvas.getContext(\"2d\");\n\n  if (ctx) {\n    return descriptors.reduce((result, descriptor) => {\n      const {\n        lastLineWidth,\n        text\n      } = withNewLines(descriptor, width, result.lastLineWidth, ctx);\n      return {\n        lastLineWidth,\n        lines: [...result.lines, text]\n      };\n    }, {\n      lastLineWidth: 0,\n      lines: []\n    }).lines;\n  }\n\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return descriptors.map(_ref => {\n    let {\n      text\n    } = _ref;\n    return text;\n  });\n}\n\nfunction toTextDescriptors(text, defaultFont) {\n  if (isTextDescriptorArray(text)) {\n    return text.map(_ref2 => {\n      let {\n        text: text2,\n        font\n      } = _ref2;\n      return {\n        text: stripNewlines(text2),\n        font: font || defaultFont\n      };\n    });\n  }\n\n  if (isStringArray(text)) {\n    return text.map(member => ({\n      text: stripNewlines(member),\n      font: defaultFont\n    }));\n  }\n\n  return [{\n    text: stripNewlines(text),\n    font: defaultFont\n  }];\n}\n\nvar newlineRegex = /(\\r\\n|\\n|\\r)/gm;\n\nfunction stripNewlines(text) {\n  return text.replace(newlineRegex, \" \");\n}\n\nfunction breakLinesEntry(text, width, font) {\n  checkFontForBlinkMacSystemFont(font);\n  const descriptors = toTextDescriptors(text, font);\n\n  if (isStringArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  if (isTextDescriptorArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  return breakLines(descriptors, width)[0];\n}\n\nvar break_lines_default = breakLinesEntry;\nexport { break_lines_default as default };","map":{"version":3,"sources":["E:/portfolio/Portfolio-Website/node_modules/break-styled-lines/dist/break-styled-lines.js"],"names":["checkFontForBlinkMacSystemFont","font","includes","console","warn","isStringArray","text","Array","isArray","length","isTextDescriptorArray","withNewLines","descriptor","width","startingX","ctx","elements","split","reduce","elements2","char","runningElement","lastChar","slice","lastLineWidth","lines","result","element","elementWidth","measureText","completeTextWidth","itFits","appendedLine","join","previousLine","precedingLines","trimEnd","trim","breakLines","descriptors","supportsOffscreenCanvas","window","canvasEl","document","createElement","canvas","transferControlToOffscreen","getContext","map","toTextDescriptors","defaultFont","text2","stripNewlines","member","newlineRegex","replace","breakLinesEntry","break_lines_default","default"],"mappings":"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","sourcesContent":["// src/break-lines.ts\nfunction checkFontForBlinkMacSystemFont(font) {\n  if (font.includes(\"BlinkMacSystemFont\")) {\n    console.warn(\"break-styled-lines: Using BlinkMacSystemFont can cause Chrome to crash in certain environments!\");\n  }\n}\nfunction isStringArray(text) {\n  return Array.isArray(text) && (text.length > 0 ? typeof text[0] === \"string\" : true);\n}\nfunction isTextDescriptorArray(text) {\n  return Array.isArray(text) && (text.length > 0 ? !isStringArray(text) : true);\n}\nfunction withNewLines(descriptor, width, startingX, ctx) {\n  const elements = descriptor.text.split(\"\").reduce((elements2, char) => {\n    const runningElement = elements2[elements2.length - 1] || \"\";\n    const lastChar = runningElement.slice(-1);\n    if (char === \" \" && lastChar !== \" \") {\n      return [...elements2, char];\n    }\n    if (char !== \" \" && lastChar === \" \") {\n      return [...elements2, char];\n    }\n    return [...elements2.slice(0, -1), `${runningElement}${char}`];\n  }, []);\n  const { lastLineWidth, lines } = elements.reduce((result, element) => {\n    ctx.font = descriptor.font;\n    const { width: elementWidth } = ctx.measureText(element);\n    const completeTextWidth = result.lastLineWidth + elementWidth;\n    const itFits = completeTextWidth <= width;\n    if (itFits) {\n      const appendedLine = [...result.lines.slice(-1), element].join(\"\");\n      return {\n        lastLineWidth: completeTextWidth,\n        lines: [...result.lines.slice(0, -1), appendedLine]\n      };\n    }\n    if (elementWidth > width && result.lastLineWidth === 0) {\n      return {\n        lastLineWidth: elementWidth,\n        lines: [...result.lines.slice(0, -1), element]\n      };\n    }\n    const previousLine = result.lines.slice(-1).join(\"\");\n    const precedingLines = [\n      ...result.lines.slice(0, -1),\n      previousLine.trimEnd()\n    ];\n    if (element.trim().length === 0) {\n      return {\n        lastLineWidth: 0,\n        lines: [...precedingLines, \"\"]\n      };\n    }\n    return {\n      lastLineWidth: elementWidth,\n      lines: [...precedingLines, element]\n    };\n  }, { lastLineWidth: startingX, lines: [] });\n  return { lastLineWidth, text: lines.join(\"\\n\") };\n}\nfunction breakLines(descriptors, width) {\n  const supportsOffscreenCanvas = \"OffscreenCanvas\" in window;\n  const canvasEl = document.createElement(\"canvas\");\n  const canvas = supportsOffscreenCanvas ? canvasEl.transferControlToOffscreen() : canvasEl;\n  canvas.width = width;\n  const ctx = canvas.getContext(\"2d\");\n  if (ctx) {\n    return descriptors.reduce((result, descriptor) => {\n      const { lastLineWidth, text } = withNewLines(descriptor, width, result.lastLineWidth, ctx);\n      return {\n        lastLineWidth,\n        lines: [...result.lines, text]\n      };\n    }, { lastLineWidth: 0, lines: [] }).lines;\n  }\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return descriptors.map(({ text }) => text);\n}\nfunction toTextDescriptors(text, defaultFont) {\n  if (isTextDescriptorArray(text)) {\n    return text.map(({ text: text2, font }) => ({\n      text: stripNewlines(text2),\n      font: font || defaultFont\n    }));\n  }\n  if (isStringArray(text)) {\n    return text.map((member) => ({\n      text: stripNewlines(member),\n      font: defaultFont\n    }));\n  }\n  return [{ text: stripNewlines(text), font: defaultFont }];\n}\nvar newlineRegex = /(\\r\\n|\\n|\\r)/gm;\nfunction stripNewlines(text) {\n  return text.replace(newlineRegex, \" \");\n}\nfunction breakLinesEntry(text, width, font) {\n  checkFontForBlinkMacSystemFont(font);\n  const descriptors = toTextDescriptors(text, font);\n  if (isStringArray(text)) {\n    return breakLines(descriptors, width);\n  }\n  if (isTextDescriptorArray(text)) {\n    return breakLines(descriptors, width);\n  }\n  return breakLines(descriptors, width)[0];\n}\nvar break_lines_default = breakLinesEntry;\nexport {\n  break_lines_default as default\n};\n"]},"metadata":{},"sourceType":"module"}