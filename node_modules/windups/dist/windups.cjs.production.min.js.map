{"version":3,"file":"windups.cjs.production.min.js","sources":["../src/Windup.ts","../src/react/Pace.tsx","../src/react/OnChar.tsx","../src/react/useWindup.ts","../src/react/renderWindup.tsx","../src/react/Pause.tsx","../src/react/WindupChildren.tsx","../src/react/Linebreaker.tsx","../src/react/CharWrapper.tsx","../src/react/Effect.tsx","../src/react/textFromChildren.ts","../src/react/useWindupString.ts"],"sourcesContent":["export type WindupMember<ElementType, MetadataType> =\n  | ElementType\n  | Windup<ElementType, MetadataType>;\nexport type Windup<ElementType, MetadataType> = [\n  Array<WindupMember<ElementType, MetadataType>>,\n  Array<WindupMember<ElementType, MetadataType>>,\n  MetadataType\n];\n\nexport function isPlayedWindup<ElementType, MetadataType>(\n  windup:\n    | PlayedWindup<ElementType, MetadataType>\n    | Windup<ElementType, MetadataType>\n): windup is PlayedWindup<ElementType, MetadataType> {\n  return windup.length === 2;\n}\n\nexport function memberIsWindup<ElementType, MetadataType>(\n  member: WindupMember<ElementType, MetadataType>\n): member is Windup<ElementType, MetadataType> {\n  // If it's not an array it can't be a windup\n  if (!Array.isArray(member)) {\n    return false;\n  }\n\n  // If it has less or more than three members it's not a windup\n  if (member.length !== 3) {\n    return false;\n  }\n\n  // If its first or second members are not arrays it's not a windup\n  if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n    return false;\n  }\n\n  // Past here we just have to hope ElementType isn't a windup.\n  return true;\n}\n\nexport function windupFromString<MetadataType>(\n  str: string,\n  metadata: MetadataType\n): Windup<string, MetadataType> {\n  return [[], str.split(\"\"), metadata];\n}\n\nexport function newWindup<ElementType, MetadataType>(\n  arg: Array<WindupMember<ElementType, MetadataType>>,\n  metadata: MetadataType\n): Windup<ElementType, MetadataType> {\n  return [[], arg, metadata];\n}\n\nexport function isUnplayed<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): boolean {\n  const [played, remaining] = windup;\n\n  if (played.length > 0) {\n    return false;\n  }\n\n  return remaining.reduce((unplayed: boolean, member) => {\n    if (memberIsWindup(member))\n      if (memberIsWindup(windup) && unplayed) {\n        return isUnplayed<ElementType, MetadataType>(member);\n      }\n    return unplayed;\n  }, true);\n}\n\nexport function isFinished<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): boolean {\n  return remaining.length === 0;\n}\n\nexport function fastForward<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  const forwardedWindup = next(windup);\n  if (isFinished(forwardedWindup)) {\n    return forwardedWindup;\n  }\n  return fastForward(forwardedWindup);\n}\n\nexport function rewind<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  if (isUnplayed(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n\n  type MemberType = WindupMember<ElementType, MetadataType>;\n\n  const mapRewind = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return rewind(member);\n    }\n    return member;\n  };\n\n  return [\n    [],\n    [...played.map(mapRewind), ...remaining.map(mapRewind)],\n    metadata\n  ];\n}\n\nexport function windupAsString<MetadataType>(\n  windup: Windup<string, MetadataType>\n): string {\n  const [played, remaining] = windup;\n\n  type MemberType = WindupMember<string, MetadataType>;\n  const stringify = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return windupAsString(member);\n    }\n    return member;\n  };\n  return [\n    played.map(stringify).join(\"\"),\n    remaining.map(stringify).join(\"\")\n  ].join(\"\");\n}\n\nexport function lastPlayedMember<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>):\n  | WindupMember<ElementType, MetadataType>\n  | undefined {\n  const playedFromRemaining = remaining.reduce(\n    (playedEl: WindupMember<ElementType, MetadataType> | undefined, member) => {\n      if (memberIsWindup(member)) {\n        if (!isUnplayed(member)) {\n          return lastPlayedElement(member);\n        }\n      }\n      return playedEl;\n    },\n    undefined\n  );\n\n  if (playedFromRemaining) {\n    return playedFromRemaining;\n  }\n\n  const last = played[played.length - 1];\n  return last;\n}\n\nexport function lastPlayedElement<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): ElementType | undefined {\n  const lastPlayed = lastPlayedMember(windup);\n\n  if (memberIsWindup(lastPlayed)) {\n    return lastPlayedElement(lastPlayed);\n  }\n\n  return lastPlayed;\n}\n\nexport type PlayedWindup<ElementType, MetadataType> = [\n  Array<ElementType>,\n  MetadataType\n];\n\nexport function playedElements<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>): Array<\n  ElementType | PlayedWindup<ElementType, MetadataType>\n> {\n  const playedTransformed = played.map(member => {\n    if (memberIsWindup(member)) {\n      const [, , metadata] = member;\n      return [playedElements(member), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >;\n    }\n    return member;\n  });\n\n  const [firstRemaning] = remaining;\n  if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n    const [, , metadata] = firstRemaning;\n\n    return [\n      ...playedTransformed,\n      [playedElements(firstRemaning), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >\n    ];\n  }\n\n  return playedTransformed;\n}\n\nexport function nextElement<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): ElementType | undefined {\n  const [nextVal] = remaining;\n\n  if (memberIsWindup(nextVal)) {\n    return nextElement(nextVal);\n  }\n\n  return nextVal;\n}\n\nexport function next<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  // start\n  // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n\n  // next\n  // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n\n  // next\n  // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n\n  // next\n  // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n\n  if (isFinished(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n  const [firstRemaining, ...restRemaining] = remaining;\n\n  if (memberIsWindup(firstRemaining)) {\n    const nextFirstRemaining = next(firstRemaining);\n\n    if (isFinished(nextFirstRemaining)) {\n      return [[...played, nextFirstRemaining], restRemaining, metadata];\n    }\n\n    return [played, [nextFirstRemaining, ...restRemaining], metadata];\n  }\n\n  return [[...played, firstRemaining], restRemaining, metadata];\n}\n","import * as React from \"react\";\nimport { isFinished, memberIsWindup, Windup } from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype MsProp = {\n  ms: number;\n};\n\ntype GetPaceProp = {\n  getPace: (char: string) => number;\n};\n\ntype PaceProps = MsProp | GetPaceProp;\n\nexport function defaultGetPace(\n  lastChar: string,\n  nextChar: string | undefined\n): number {\n  switch (lastChar) {\n    case \"—\":\n    case \"…\":\n      return 200;\n    case \".\":\n    case \",\":\n      return 150;\n    case \"?\":\n    case \"!\":\n      if (nextChar !== \"!\" && nextChar !== \"?\") {\n        return 150;\n      }\n      return 20;\n    case \"-\":\n    case \" \":\n    case \"\\n\":\n      return 0;\n    default:\n      return 20;\n  }\n}\n\nconst Pace: React.FC<React.PropsWithChildren<PaceProps>> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isPaceElement(\n  element: React.ReactElement\n): element is React.ReactElement<PaceProps> {\n  return element.type === Pace;\n}\n\nexport function isMsProp(props: PaceProps): props is MsProp {\n  if (\"ms\" in props) {\n    return true;\n  }\n  return false;\n}\n\nexport function paceFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(\n  windup: W,\n  parentPace?: (char: string, nextChar: string | undefined) => number\n): ((char: string, nextChar: string | undefined) => number) | undefined {\n  if (isFinished(windup)) {\n    return undefined;\n  }\n\n  const [, remaining, metadata] = windup;\n\n  const [firstRemaining] = remaining;\n\n  if (firstRemaining && memberIsWindup(firstRemaining)) {\n    return paceFromWindup(firstRemaining, metadata.pace || parentPace);\n  }\n\n  return metadata.pace || parentPace;\n}\n\nexport default Pace;\n","import * as React from \"react\";\nimport {\n  memberIsWindup,\n  Windup,\n  lastPlayedMember,\n  isUnplayed\n} from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype OnCharProps = {\n  children: React.ReactNode;\n  fn: (char: string) => void;\n};\n\nconst OnChar: React.FC<OnCharProps> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isOnCharElement(\n  element: React.ReactElement\n): element is React.ReactElement<OnCharProps> {\n  return element.type === OnChar;\n}\n\n// Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\nexport function onCharsFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(windup: W): ((char: string) => void)[] {\n  const [, remaining, metadata] = windup;\n  const lastPlayed = lastPlayedMember(windup);\n  const [firstRemaining] = remaining;\n\n  let onChars = [];\n\n  if (lastPlayed && memberIsWindup(lastPlayed)) {\n    onChars.push(...onCharsFromWindup(lastPlayed));\n  }\n\n  if (\n    firstRemaining &&\n    memberIsWindup(firstRemaining) &&\n    !isUnplayed(firstRemaining)\n  ) {\n    onChars.push(...onCharsFromWindup(firstRemaining));\n  }\n\n  if (metadata.onChar) {\n    onChars.push(metadata.onChar);\n  }\n\n  return onChars;\n}\n\nexport default OnChar;\n","import * as React from \"react\";\nimport { defaultGetPace, paceFromWindup } from \"./Pace\";\nimport {\n  isFinished,\n  lastPlayedElement,\n  next,\n  fastForward,\n  rewind,\n  Windup,\n  nextElement\n} from \"../Windup\";\nimport { onCharsFromWindup } from \"./OnChar\";\n\ntype WindupReducerState<M> = {\n  windup: Windup<string, M>;\n  didFinishOnce: boolean;\n};\n\ntype WindupReducerAction<M> =\n  | {\n      type: \"replace\";\n      windup: Windup<string, M>;\n    }\n  | {\n      type: \"next\";\n    }\n  | {\n      type: \"rewind\";\n    }\n  | {\n      type: \"fast-forward\";\n    }\n  | {\n      type: \"finish\";\n    };\n\nfunction initWindupState<M>(windup: Windup<string, M>): WindupReducerState<M> {\n  return { windup, didFinishOnce: false };\n}\n\ntype ReducerType<M> = (\n  prevState: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n) => WindupReducerState<M>;\n\nfunction windupReducer<M>(\n  state: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n): WindupReducerState<M> {\n  switch (action.type) {\n    case \"replace\":\n      return initWindupState(action.windup);\n    case \"next\":\n      return { ...state, windup: next(state.windup) };\n    case \"rewind\":\n      return { windup: rewind(state.windup), didFinishOnce: false };\n    case \"fast-forward\":\n      return { ...state, windup: fastForward(state.windup) };\n    case \"finish\":\n      return { ...state, didFinishOnce: true };\n    default:\n      return state;\n  }\n}\n\nexport interface HookMetadata {\n  onChar?: (char: string) => void;\n  pace?: (char: string, nextChar: string | undefined) => number;\n}\n\nexport default function useWindup<M extends HookMetadata>(\n  windupInit: Windup<string, M>,\n  options: {\n    onFinished?: () => void;\n    skipped?: boolean;\n  }\n): {\n  windup: Windup<string, M>;\n  skip: () => void;\n  pause: () => void;\n  resume: () => void;\n  rewind: () => void;\n  isFinished: boolean;\n} {\n  const [{ windup, didFinishOnce }, dispatch] = React.useReducer<\n    ReducerType<M>,\n    Windup<string, M>\n  >(windupReducer, windupInit, initWindupState);\n\n  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);\n  const windupIsFinished = isFinished(windup);\n\n  const nextCharAtRef = React.useRef<number | null>(null);\n  const pauseDelayRemainingRef = React.useRef<number | null>(null);\n  const isPausedRef = React.useRef<boolean>(false);\n\n  const skip = React.useCallback(() => {\n    if (!windupIsFinished) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n  }, [windupIsFinished]);\n\n  const pause = React.useCallback(() => {\n    if (isPausedRef.current === true) {\n      return;\n    }\n\n    isPausedRef.current = true;\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      pauseDelayRemainingRef.current = Math.max(\n        0,\n        (nextCharAtRef.current ?? 0) - Date.now()\n      );\n    }\n  }, []);\n\n  const resume = React.useCallback(() => {\n    if (isPausedRef.current !== true) {\n      return;\n    }\n\n    if (!windupIsFinished) {\n      setTimeout(() => {\n        isPausedRef.current = false;\n        dispatch({ type: \"next\" });\n      }, pauseDelayRemainingRef.current ?? 0);\n    }\n  }, [windupIsFinished]);\n\n  const rewind = React.useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    dispatch({ type: \"rewind\" });\n  }, []);\n\n  // If windup arg changes, we should reset\n  React.useEffect(() => {\n    dispatch({ type: \"replace\", windup: windupInit });\n  }, [windupInit]);\n\n  // If skipped is changes to true, we should skip\n  // And if it's changed to false, we should restart\n  React.useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    if (options.skipped) {\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n    if (options.skipped === false) {\n      dispatch({ type: \"rewind\" });\n    }\n  }, [options.skipped]);\n\n  // When the windup changes, onChar should fire\n  React.useEffect(() => {\n    const onChars = onCharsFromWindup(windup);\n    const lastEl = lastPlayedElement(windup);\n    if (onChars.length > 0 && lastEl) {\n      onChars.forEach(onChar => {\n        onChar(lastEl);\n      });\n    }\n  }, [windup]);\n\n  // If windup finishes, the onFinished should fire\n  React.useEffect(() => {\n    // Put this in a new context so that the windup finishes visually before firing this\n    if (didFinishOnce === false && windupIsFinished) {\n      const timeout = setTimeout(() => {\n        if (options.onFinished) {\n          options.onFinished();\n        }\n        dispatch({ type: \"finish\" });\n      }, 0);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [didFinishOnce, windupIsFinished, options]);\n\n  // the windup effect itself\n  React.useEffect(() => {\n    if (!windupIsFinished) {\n      const getPace = paceFromWindup(windup) || defaultGetPace;\n      const lastEl = lastPlayedElement(windup);\n      const nextEl = nextElement(windup);\n\n      const pace = lastEl ? getPace(lastEl, nextEl) : 0;\n\n      nextCharAtRef.current = Date.now() + pace;\n\n      if (isPausedRef.current !== true) {\n        timeoutRef.current = setTimeout(() => {\n          dispatch({ type: \"next\" });\n        }, pace);\n      }\n\n      return () => {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n        }\n      };\n    }\n  }, [windup, windupIsFinished]);\n\n  return {\n    windup,\n    skip,\n    pause,\n    resume,\n    rewind,\n    isFinished: windupIsFinished\n  };\n}\n","import * as React from \"react\";\nimport { ChildrenMetadata, ChildrenWindup } from \"./WindupChildren\";\nimport { PlayedWindup, playedElements, isPlayedWindup } from \"../Windup\";\nimport { StringMetadata, StringWindup } from \"./useWindupString\";\n\nexport type PlayedChildrenWindup = PlayedWindup<string, ChildrenMetadata>;\nexport type PlayedStringWindup = PlayedWindup<string, StringMetadata>;\n\nexport function renderStringWindup(\n  windup: StringWindup | PlayedStringWindup\n): string {\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const inner = played.reduce((acc: string, playedEl) => {\n    if (typeof playedEl === \"string\") {\n      return acc + playedEl;\n    }\n\n    return acc + renderStringWindup(playedEl);\n  }, \"\");\n\n  return inner;\n}\n\nconst VOID_TAGS = [\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"command\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n];\n\nexport function renderChildrenWindup(\n  windup: ChildrenWindup | PlayedChildrenWindup\n): React.ReactNode {\n  const metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const Outer = metadata.element || React.Fragment;\n\n  if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  const inner = played.reduce((acc: React.ReactNode[], playedEl) => {\n    if (typeof playedEl === \"string\") {\n      const accButLast = acc.slice(0, acc.length - 1);\n      const last = acc[acc.length - 1];\n\n      return last && typeof last === \"string\"\n        ? [...accButLast, last + playedEl]\n        : [...acc, playedEl];\n    }\n\n    return [...acc, renderChildrenWindup(playedEl)];\n  }, []);\n\n  if (\n    typeof metadata.element === \"string\" &&\n    VOID_TAGS.includes(metadata.element)\n  ) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  return (\n    <Outer key={metadata.key} {...metadata.props}>\n      {inner}\n    </Outer>\n  );\n}\n","import * as React from \"react\";\n\ntype PauseProps = {\n  ms: number;\n};\n\nconst Pause: React.FC<PauseProps> = () => {\n  return null;\n};\n\nexport function isPauseElement(\n  element: React.ReactElement\n): element is React.ReactElement<PauseProps> {\n  return element.type === Pause;\n}\n\nexport default Pause;\n","import * as React from \"react\";\nimport {\n  newWindup,\n  Windup,\n  WindupMember,\n  windupFromString,\n  memberIsWindup\n} from \"../Windup\";\nimport { isPaceElement, isMsProp } from \"./Pace\";\nimport { isOnCharElement } from \"./OnChar\";\nimport { isPauseElement } from \"./Pause\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderChildrenWindup } from \"./renderWindup\";\n\nconst WindupContext = React.createContext({\n  skip: () => {\n    console.warn(\n      \"Tried to use the useSkip hook outside of a WindupChildren component!!\"\n    );\n  },\n  pause: () => {\n    console.warn(\n      \"Tried to use the usePause hook outside of a WindupChildren component!!\"\n    );\n  },\n  resume: () => {\n    console.warn(\n      \"Tried to use the useResume hook outside of a WindupChildren component!!\"\n    );\n  },\n  rewind: () => {\n    console.warn(\n      \"Tried to use the useRewind hook outside of a WindupChildren component!\"\n    );\n  },\n  isFinished: false\n});\n\nexport function useSkip() {\n  const { skip } = React.useContext(WindupContext);\n  return skip;\n}\n\nexport function usePause() {\n  const { pause } = React.useContext(WindupContext);\n  return pause;\n}\n\nexport function useResume() {\n  const { resume } = React.useContext(WindupContext);\n  return resume;\n}\n\nexport function useRewind() {\n  const { rewind } = React.useContext(WindupContext);\n  return rewind;\n}\n\nexport function useIsFinished() {\n  const { isFinished } = React.useContext(WindupContext);\n  return isFinished;\n}\n\nexport interface ChildrenMetadata extends HookMetadata {\n  element: React.ElementType | string | undefined;\n  props?: any;\n  ref?: any;\n  key?: string | number | null;\n}\n\nexport type ChildrenWindup = Windup<string, ChildrenMetadata>;\ntype ChildrenWindupMember = WindupMember<string, ChildrenMetadata>;\n\nfunction reduceWindupArgs(\n  prevArgs: ChildrenWindupMember[],\n  children: React.ReactNode\n) {\n  if (typeof children === \"string\") {\n    return [...prevArgs, ...children.split(\"\")];\n  }\n\n  if (typeof children === \"number\") {\n    return [...prevArgs, ...children.toString().split(\"\")];\n  }\n\n  if (!React.isValidElement(children)) {\n    return prevArgs;\n  }\n\n  const { children: childrenChildren, ...restProps } = children.props;\n\n  const paceMetaData = isPaceElement(children)\n    ? {\n        pace: (char: string) => {\n          if (isMsProp(children.props)) {\n            return children.props.ms;\n          }\n          return children.props.getPace(char);\n        }\n      }\n    : {};\n\n  const onCharMetaData = isOnCharElement(children)\n    ? {\n        onChar: children.props.fn\n      }\n    : {};\n\n  const keyProp = children.key ? { key: children.key } : {};\n\n  if (isPauseElement(children)) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: React.Fragment,\n        ...keyProp,\n        props: { children: undefined },\n        pace: () => children.props.ms\n      })\n    ];\n  }\n\n  if (childrenChildren === undefined) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { ...restProps, children: undefined },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (typeof childrenChildren === \"string\") {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(childrenChildren, {\n        element: children.type,\n        props: restProps,\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (childrenChildren instanceof Function) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { children: childrenChildren, ...restProps },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  const newArgs: ChildrenWindupMember[] = React.Children.toArray(\n    childrenChildren\n  ).reduce(reduceWindupArgs, []);\n\n  const argsWithMetadata = newArgs.map(member => {\n    if (memberIsWindup(member)) {\n      const [played, remaining, metadata] = member;\n      return [\n        played,\n        remaining,\n        {\n          ...paceMetaData,\n          ...onCharMetaData,\n          ...metadata\n        }\n      ] as ChildrenWindupMember;\n    }\n    return member;\n  });\n\n  return [\n    ...prevArgs,\n    newWindup<string, ChildrenMetadata>(argsWithMetadata, {\n      element: children.type,\n      props: restProps,\n      ...keyProp,\n      ...paceMetaData,\n      ...onCharMetaData\n    })\n  ];\n}\n\ntype WindupChildrenProps = {\n  children: React.ReactNode;\n  onFinished?: () => void;\n  skipped?: boolean;\n  isPaused?: boolean;\n};\n\nfunction buildKeyString(children: React.ReactNode): string {\n  if (children === null || children === undefined) {\n    return \"\";\n  }\n\n  const keys = React.Children.map(children, child => {\n    if (typeof child === \"string\") {\n      return child;\n    }\n\n    if (typeof child === \"number\") {\n      return child.toString();\n    }\n\n    if (React.isValidElement(child)) {\n      return `#${child.key || \"\"}<${buildKeyString(child.props.children)}>`;\n    }\n\n    return \"\";\n  });\n\n  if (!keys) {\n    return \"\";\n  }\n\n  return keys.join(\",\");\n}\n\nfunction useChildrenMemo<T>(factory: () => T, children: React.ReactNode) {\n  // Omitting children in favour of using a key instead\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoChildren = React.useMemo(factory, [buildKeyString(children)]);\n\n  return memoChildren;\n}\n\nconst WindupChildren: React.FC<WindupChildrenProps> = ({\n  children,\n  onFinished,\n  skipped,\n  isPaused = false\n}) => {\n  const windupInit = useChildrenMemo(() => {\n    return newWindup<string, ChildrenMetadata>(\n      React.Children.toArray(children).reduce(reduceWindupArgs, []),\n      { element: undefined }\n    );\n  }, children);\n\n  const { windup, skip, pause, resume, rewind, isFinished } = useWindup(\n    windupInit,\n    {\n      onFinished,\n      skipped\n    }\n  );\n\n  React.useEffect(() => {\n    if (isPaused === true) {\n      pause();\n    } else {\n      resume();\n    }\n  }, [isPaused, pause, resume]);\n\n  return (\n    <WindupContext.Provider\n      value={{\n        skip,\n        pause,\n        resume,\n        rewind,\n        isFinished\n      }}\n    >\n      {renderChildrenWindup(windup)}\n    </WindupContext.Provider>\n  );\n};\n\nexport default WindupChildren;\n","import * as React from \"react\";\nimport breakLines from \"break-styled-lines\";\n\nfunction makeGetDescriptorsOfChildren(defaultFontStyle: string) {\n  return (\n    descriptors: { text: string; font: string }[],\n    children: React.ReactNode\n  ): { text: string; font: string }[] => {\n    if (typeof children === \"string\") {\n      return [...descriptors, { text: children, font: defaultFontStyle }];\n    }\n\n    if (typeof children === \"number\") {\n      return [\n        ...descriptors,\n        { text: children.toString(), font: defaultFontStyle }\n      ];\n    }\n\n    if (!React.isValidElement(children)) {\n      return descriptors;\n    }\n\n    if (\n      isStyledTextElement(children) &&\n      typeof children.props.children === \"string\"\n    ) {\n      return [\n        ...descriptors,\n        { text: children.props.children, font: children.props.fontStyle }\n      ];\n    }\n\n    if (isStyledTextElement(children)) {\n      return [\n        ...descriptors,\n        ...React.Children.toArray(children.props.children).reduce(\n          makeGetDescriptorsOfChildren(children.props.fontStyle),\n          []\n        )\n      ];\n    }\n\n    return [\n      ...descriptors,\n      ...React.Children.toArray(children.props.children).reduce(\n        makeGetDescriptorsOfChildren(defaultFontStyle),\n        []\n      )\n    ];\n  };\n}\n\nfunction reinsertStringsIntoChildren(\n  [accChildren, accStrings]: [React.ReactNode[], string[]],\n  children: React.ReactNode\n): [React.ReactNode[], string[]] {\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    const [firstString, ...restStrings] = accStrings;\n    return [[...accChildren, firstString], restStrings];\n  }\n\n  if (!React.isValidElement(children)) {\n    return [accChildren, accStrings];\n  }\n\n  const [subChildrenAcc, subStringsAcc] = React.Children.toArray(\n    children.props.children\n  ).reduce(reinsertStringsIntoChildren, [[], accStrings]);\n\n  return [\n    [\n      ...accChildren,\n      React.cloneElement(children, {\n        children: subChildrenAcc\n      })\n    ],\n    subStringsAcc\n  ];\n}\n\ntype StyledTextProps = { children: React.ReactNode; fontStyle: string };\n\nfunction isStyledTextElement(\n  element: React.ReactElement\n): element is React.ReactElement<StyledTextProps> {\n  return element.type === StyledText;\n}\n\nexport function StyledText({ children }: StyledTextProps) {\n  return <>{children}</>;\n}\n\ntype LinebreakerProps = {\n  children: React.ReactNode;\n  fontStyle: string;\n  width: number;\n};\n\nconst Linebreaker: React.FC<LinebreakerProps> = ({\n  children,\n  fontStyle,\n  width\n}) => {\n  // CAVEATS:\n  // fontStyle must match the font style of the characters inside\n  // non-character elements must not add width to the line.\n  // must be used OUTSIDE of WindupChildren component\n\n  const childrenArray = React.Children.toArray(children);\n  const descriptors = childrenArray.reduce(\n    makeGetDescriptorsOfChildren(fontStyle),\n    []\n  );\n\n  const transformedStrings = breakLines(descriptors, width, fontStyle);\n\n  const [\n    transformedChildren\n  ] = childrenArray.reduce(reinsertStringsIntoChildren, [\n    [],\n    transformedStrings\n  ]);\n\n  return <div style={{ whiteSpace: \"pre\" }}>{transformedChildren}</div>;\n};\n\nexport default Linebreaker;\n","import * as React from \"react\";\n\ntype CharWrapperProps = {\n  children: React.ReactNode;\n  element: React.ElementType;\n};\n\nfunction wrapChildren(children: React.ReactNode, Wrapper: React.ElementType) {\n  if (typeof children === \"string\") {\n    return children\n      .split(\"\")\n      .map((char, i) =>\n        char === \"\\n\" ? char : <Wrapper key={`${char}-${i}`}>{char}</Wrapper>\n      );\n  }\n\n  if (typeof children === \"number\") {\n    return children\n      .toString()\n      .split(\"\")\n      .map(char => <Wrapper>{char}</Wrapper>);\n  }\n\n  if (!React.isValidElement(children)) {\n    return <React.Fragment />;\n  }\n\n  if (children.props.children) {\n    const Outer = children.type;\n\n    if (children.props.children instanceof Function) {\n      return <Outer key={children.key} {...children.props} />;\n    }\n\n    return (\n      <Outer key={children.key} {...children.props}>\n        {React.Children.map(children.props.children, ch => {\n          return wrapChildren(ch, Wrapper);\n        })}\n      </Outer>\n    );\n  }\n\n  return children;\n}\n\nconst CharWrapper: React.FC<CharWrapperProps> = ({ children, element }) => {\n  return (\n    <>\n      {React.Children.map(children, ch => {\n        return wrapChildren(ch, element);\n      })}\n    </>\n  );\n};\n\nexport default CharWrapper;\n","import * as React from \"react\";\n\ntype EffectProps = {\n  fn: () => void;\n};\n\nconst Effect: React.FC<EffectProps> = ({ fn }) => {\n  React.useEffect(() => {\n    fn();\n    // We can safely omit fn from dependencies as if its value changes\n    // the whole windup will be re-rendered anyway\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return null;\n};\n\nexport default Effect;\n","import * as React from \"react\";\n\nexport default function textFromChildren(children: React.ReactNode): string {\n  const text = React.Children.map(children, ch => {\n    if (typeof ch === \"string\") {\n      return ch;\n    }\n\n    if (typeof ch === \"number\") {\n      return ch.toString();\n    }\n\n    if (!React.isValidElement(ch)) {\n      return \"\";\n    }\n\n    if (ch.props.children) {\n      return textFromChildren(ch.props.children);\n    }\n\n    return \"\";\n  });\n\n  if (!text) {\n    return \"\";\n  }\n\n  return text.join(\"\");\n}\n","import * as React from \"react\";\nimport { windupFromString, Windup } from \"../Windup\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderStringWindup } from \"./renderWindup\";\n\nexport type WindupOptions = {\n  onChar?: (char: string) => void;\n  onFinished?: () => void;\n  pace?: (char: string) => number;\n  skipped?: boolean;\n};\n\nexport type StringMetadata = HookMetadata;\n\nexport type StringWindup = Windup<string, StringMetadata>;\n\nexport default function useWindupString(\n  text: string,\n  options: WindupOptions = {}\n): [\n  string,\n  {\n    skip: () => void;\n    pause: () => void;\n    resume: () => void;\n    rewind: () => void;\n    isFinished: boolean;\n  }\n] {\n  const windupInit = React.useMemo(() => {\n    return windupFromString<StringMetadata>(text, options);\n    // We can omit options as this is used as an initialisation value and options will not change it\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [text]);\n\n  const { windup, skip, pause, resume, rewind, isFinished } = useWindup(\n    windupInit,\n    options\n  );\n\n  const rendered = renderStringWindup(windup);\n  React.useDebugValue(rendered);\n\n  return [rendered, { skip, pause, resume, rewind, isFinished }];\n}\n"],"names":["isPlayedWindup","windup","length","memberIsWindup","member","Array","isArray","windupFromString","str","metadata","split","newWindup","arg","isUnplayed","reduce","unplayed","isFinished","fastForward","forwardedWindup","next","rewind","remaining","mapRewind","map","lastPlayedMember","played","playedEl","lastPlayedElement","undefined","lastPlayed","playedElements","playedTransformed","firstRemaning","firstRemaining","restRemaining","nextFirstRemaining","defaultGetPace","lastChar","nextChar","Pace","React","children","OnChar","initWindupState","didFinishOnce","windupReducer","state","action","type","useWindup","windupInit","options","dispatch","timeoutRef","windupIsFinished","nextCharAtRef","pauseDelayRemainingRef","isPausedRef","skip","current","clearTimeout","pause","Math","max","Date","now","resume","setTimeout","skipped","onChars","onCharsFromWindup","push","onChar","lastEl","forEach","timeout","onFinished","getPace","paceFromWindup","parentPace","pace","nextEl","nextElement","nextVal","VOID_TAGS","Pause","WindupContext","console","warn","reduceWindupArgs","prevArgs","toString","props","childrenChildren","restProps","paceMetaData","char","ms","onCharMetaData","element","isOnCharElement","fn","keyProp","key","isPauseElement","Function","argsWithMetadata","toArray","buildKeyString","keys","child","join","reinsertStringsIntoChildren","accChildren","accStrings","firstString","restStrings","subStringsAcc","isStyledTextElement","StyledText","ch","wrapChildren","Wrapper","i","Outer","fontStyle","width","childrenArray","descriptors","makeGetDescriptorsOfChildren","defaultFontStyle","text","font","transformedStrings","breakLines","style","whiteSpace","isPaused","factory","useChildrenMemo","Provider","value","renderChildrenWindup","Object","includes","inner","acc","accButLast","slice","last","textFromChildren","rendered","renderStringWindup"],"mappings":"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"}